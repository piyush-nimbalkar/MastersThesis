\chapter{Related Work and Discussion}
\thispagestyle{plain}

\label{Related Work and Discussion}

Forrest \(et\ al.\)~\cite{32} first proposed the system call malware detection schemes by building a database of normal system call sequences. Warrender \(et\ al.\)~\cite{warrender1999detecting} extended this idea by using hidden Markov models (HMMs) to model sequences of normal system calls. Other researchers Burguera \(et\ al.\), Creech \(et\ al.\)~\cite{34,35} adapted artificial neural network to perform intrusion detection. Kruegel \(et\ al.\)~\cite{36} proposed to use system call arguments to improve the performance of host-based intrusion detection. Maggi \(et\ al.\)~\cite{37} proposed to cluster similar system calls or similar system call arguments to further improve the accuracy. 

Earlier researchers~\cite{38,39} also used SOM for network intrusion detection by clustering system call arguments such as user name, connection type, and connection time. Gao \(et\ al.\) and Garfinkel~\cite{40,41} perform real-time anomaly detection based on differences between execution graphs and the replica graphs constructed using system call traces and runtime information (e.g., return addresses). 

Traditional system call based intrusion detection approaches have to collect all system calls made by the target process, as there is no clear boundary to reduce the collection scope. This increases both noise and design complexity of intrusion detection.

Crowdroid~\cite{34} collects system calls on smartphones and sends system call statistics to a centralized server. Based on the theory of crowdsourcing, symptoms that are shared by a small number of devices are treated as abnormal. Similarly, Paranoid Android Portokalidis \(et\ al.\)~\cite{42} runs a daemon on the phone to collect behaviors and a virtual replica of the phone in the cloud. The daemon transmits collected behaviors to the cloud and the virtual phone replays the actions happening on the smartphone based on the collected behaviors. Both Crowdroid and Paranoid Android incur 15-30\% overhead to smartphone devices. 

SmartSiren~\cite{43} gathers and reports communication information to a proxy for anomaly detection. Besides the runtime overhead, propagating sensitive communication data to a public server might be a privacy concern for users. Recent work has explored using specific subsets of system calls for smartphone security. Isohara \(et\ al.\)~\cite{44} monitor a pre-defined subset of system calls such as open on smartphones. pBMDS~\cite{45} hooks input-event related functions (e.g., sys\_read() for keyboard events, specific drivers for touch events) to collect system calls related to user interaction behaviors (e.g., GUI events). It then performs malware detection using HMMs. This requires significant changes to operating system and are requires custom kernel modules.

Moser \(et\ al.\)~\cite{46} monitor system calls executed when a program tries to terminate, with the intention of understanding how malware evades detection in virtualized test environments. Bayer \(et\ al.\)~\cite{47} create malicious application behavioural profiles by combining system call traces with system call dependency and operation information. Kolbitsch \(et\ al.\)~\cite{48} generate hard to obfuscate models that track the dependencies of system calls in known malware, which they then can use to detect similar type of malware. CloudAV~\cite{49} intercepts every open system call and extracts the target file. It compares this signature with signatures of abnormal files maintained in the cloud to detect the access of malicious files. DroidRanger~\cite{50} utilizes a signature-based algorithm to detect known malware from markets and monitors sensitive API accesses to discover zero-day malware. These techniques due to there nature has very high false positive rate.

Several researchers have also applied machine learning to statically detect malicious applications based on their permissions~\cite{50,46,19}; however, the root exploit malware would be able to defeat these approaches. Previous work has been done to automatically respond to malicious attacks on networked hosts. For example, Somayaji \(et\ al.\)~\cite{51} delay anomalous system calls with increasing delay durations to prevent security violations such as a buffer overflow. Feinstein \(et\ al.\)~\cite{52} dynamically apply filtering rules when a DDoS attack is detected. Balepin \(et\ al.\)~\cite{53} use a cost model to compare predefined exploit costs with various predefined benefits to select the best response to a compromised system resource. Garfinkel \(et\ al.\)~\cite{41} sandbox applications by using user defined policies to control access to system resources by blocking certain system calls. Additionally, their tool emulates access to these resources to prevent applications from crashing. These changes are either intrusive to application or depends on the user knowledge. Not every user is aware of all security related permission and its impact. So user defined detection or response rules would fail.

	In contrast to above all approaches, we try to use noised version of system calls with unsupervised deep learning (SdA) method. As a result, our system is more stable and resilient to noisy input and can work on limited input data set. Also our system does not require any kernel related changes to android operating system which makes it more viable and practical solution.