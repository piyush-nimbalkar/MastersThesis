\chapter{System Design}
\thispagestyle{plain}
\label{System Design}

\section{Architecture Overview}

\begin{figure}[h]
\includegraphics[width=\textwidth, height=\textheight, keepaspectratio] {method_android_app_trace.png}
\caption{System for Android Malware Classification}
\label{fig:method_android_app_trace}
\end{figure}

The architecture of system is modular in nature and is designed to accommodate various repository locations. Malware samples can be located on a local storage or over a network storage. The system is also designed to automate data collection from android device and provide all housekeeping services that might be required by user to run various malicious application on a android device in a batch mode. System is capable of collecting system call and resource consumption related trace files. Also it can collect power related information for given application run. Figure~\ref{fig:method_android_app_trace} shows the block diagram of our system. System consists of five major modules:

\begin{figure}
\includegraphics[width=\textwidth, height=\textheight, keepaspectratio] {data_pipeline.png}
\caption{Data Processing \& Knowledge Generation}
\label{method_andriod_data_pipeline}
\end{figure}

\subsection{Data Reader}
\label{Data Reader}
This module can read data from a local disk or over a network. This module traverse all directories of malware families one by one and grabs the malware sample (.apk file) from that directory for analysis. Each apk file is provided to 'House Keeping' module.
\subsection{House Keeping}
\label{House Keeping}
This module is responsible for installation of malicious application on a android phone. We can use android emulator as well. Following activities are performed by House Keeping module.
\begin{itemize}
\item Installation of malicious application on a android phone.
\item Informing Action Generator module about newly installed application.
\item Removal of malicious application from a android phone.
\item Collect log files generated for given application run.
\end{itemize}
\subsection{Action Generator}
\label{Action Generator}
This module is built on top of 'Android Monkey' tool. As per user configuration, this module generates pseudo-random streams of user events such as clicks, touches or gestures, as well as a number of system-level events. If required user can generate same sequence of actions. As a default action, tool is configured to generate random actions to mimic the user behavior.
\subsection{Activity Logger}
\label{Activity Logger}
This module is responsible for logging all system calls and resource consumption related information on a android phone. This module requires "root" permission and needs to be installed on the "system" partition of the android phone.
\subsection{Data Preprocessor}
\label{Data Preprocessor}
Once all log files are collected for the experiment run, this module converts collected data into single csv formatted file. Two csv file are generated by this module. These files are used for:
\begin{itemize}
\item Binary classification, where target is set to binary value (0 or 1).
\item Multiclass classification, where target is set to "malware family" name.
\end{itemize}
\label{Knowledge Generation}
This module is responsible for data massaging, feature selection and running various algorithms for experiment. This module can be located on local system or in the cloud.

\section{System Input}
\label{System Input}
The system requires android malware repository location. Expected directory structure is shown in figure ~\ref{fig:malware_dir_struct} where every subdirectory represents \(Malware Famliy Name\) and each \(.apk\) file represent the android application specimen. System also expects non malicious application to be placed under \(benign\_apps\) subdirectory.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{malware_dir_struct.png}
\caption{Input Directory Structure}
\label{fig:malware_dir_struct}
\end{figure}

\section{System Output}
\label{System Output}
For each malware sample system generates a log file on a Android device. System pulls this log file and places into the same subdirectory from where the application specimen, apk file, was selected for installation. To resolve multiple runs of same application, system adds timestamps at the end of filename. All these logs files are then parsed into a csv file where frequency of each system call forms the feature and malware family name forms the target label. The system generates two out files.
\begin{itemize}
\item b\_android\_apps\_run.csv : file for binary class classification (malicious\/benign).
\item m\_android\_apps\_run.csv : file for multi class classification (malware families).
\end{itemize}
Typically user needs to normalise the input before building a classifier on this data. We perform this step in two stages. 
\begin{itemize}
\item Feature Selection: We use $sparseLDA$ normalization algorithm for feature selection.
\item Normalize: We use Zscore normalization technique for our analysis.
\end{itemize}

This would generate a matrix of size \(N \times W\), where \(W\) is selected features with target as a last column and \(N\) is the number of application run for given dataset. This matrix contains normalized values and then used as a input to various classifiers. Binary classification is done to detect malicious vs benign apps from given data set. Multiclass classification is done to classify given application into malware families. We use various algorithms such as RandomeForest, AdaBoost, SVM, Neural Network, SdA for classification. Results are discussed in the section~\ref{Results}.
